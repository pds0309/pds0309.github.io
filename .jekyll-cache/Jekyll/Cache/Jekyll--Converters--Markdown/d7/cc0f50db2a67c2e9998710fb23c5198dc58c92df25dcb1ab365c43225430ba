I" #<h2 id="백준-2565-전깃줄">백준-2565-전깃줄</h2>

<hr />

<h3 id="문제설명링크---"><a href="https://www.acmicpc.net/problem/2565">문제설명링크   </a></h3>
<p><br /></p>

<ul>
  <li><a href="#나의-풀이">풀이</a></li>
  <li><a href="#자바-풀이-코드">코드</a></li>
</ul>

<p><br /></p>

<h3 id="문제요약">문제요약</h3>

<ul>
  <li>두 전봇대 사이에 전깃줄이 있는데 모든 전깃줄이 교차하지 않게 전깃줄을 제거하는 최소 개수를 구하라.</li>
  <li>한 위치에 두 개 이상의 전깃줄이 연결될 수는 없다.
<br /></li>
</ul>

<p><br /></p>
<h3 id="입력">입력<br /></h3>
<ul>
  <li>첫째 줄에 두 전본대 사이의 전깃줄 개수가 주어짐 &lt;= 100</li>
  <li>전봇대 A,B에 연결되는 전깃줄 번호가 주어짐 &lt;= 500</li>
</ul>

<h3 id="출력--">출력  <br /></h3>

<ul>
  <li>첫째 줄에 남아있는 모든 전깃줄이 서로 교차하지 않게 하기 위해 없애야 하는 전깃줄의 최소 개수를 출력한다.</li>
</ul>

<h3 id="입력예시">입력예시<br /></h3>

<p>8<br />
1 8<br />
3 9<br />
2 2<br />
4 1<br />
6 4<br />
10 10<br />
9 7<br />
7 6<br /></p>

<h3 id="출력예시">출력예시<br /></h3>

<p>3<br /></p>

<p><br /></p>

<h3 id="풀이">풀이<br /></h3>
<ul>
  <li>전깃줄 개수가 N이라면</li>
  <li>A[N] : 왼쪽 전봇대에서의 전깃줄 번호를 오름차순으로 할 때 해당 인덱스의 오른쪽 전깃줄 번호</li>
  <li>D[N] : 1~N번째 전깃줄 까지에서 교차하지 않는 전깃줄 최대개수</li>
  <li>
    <p>D[N] 은 A[1]~A[N-1] &lt; A[N] 인 부분에 대해서(전깃줄이 겹치지 않는 경우)  D[1]~D[N-1] 까지의 최대값 + 1이 된다.
<br /></p>
  </li>
  <li>D[N] 에서 가장 큰 값은 주어진 전깃줄들 중 겹치지 않는 가장 많은 부분에 대한 개수를 나타낸다.
    <ul>
      <li>따라서 전체 전깃줄 개수에서 이 수를 빼면 정답이 된다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="자바-풀이-코드">자바 풀이 코드</h3>

<p><br /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.BufferedReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStreamReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">BufferedReader</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="nc">StringTokenizer</span> <span class="n">st</span><span class="o">;</span>
<span class="c1">//주어진 전깃줄들을 왼쪽전봇대의 값을 key로하여 오름차순 정렬</span>
        <span class="nc">SortedMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">sm</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">;</span> <span class="n">i</span> <span class="o">++){</span>
            <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
            <span class="n">sm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">()),</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">()));</span>
        <span class="o">}</span>
<span class="c1">// key는 왼쪽전봇대의 값 , value 는 해당 전깃줄까지 선택할 때 겹치지 않는 전깃줄의 수 최대값</span>
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">hs</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="c1">// int keys 는 현재 전깃줄</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">keys:</span> <span class="n">sm</span><span class="o">.</span><span class="na">keySet</span><span class="o">()){</span>
            <span class="n">hs</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">keys</span> <span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
<span class="c1">// int ks 는 이전의 전깃줄들</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">ks</span> <span class="o">:</span> <span class="n">sm</span><span class="o">.</span><span class="na">keySet</span><span class="o">()){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">ks</span> <span class="o">&gt;=</span> <span class="n">keys</span><span class="o">){</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
<span class="c1">// 현재 전깃줄보다 이전 전깃줄의 오른쪽 값이 작다면 겹치지 않는다는 뜻임</span>
                <span class="k">if</span><span class="o">(</span><span class="n">sm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">ks</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">sm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">keys</span><span class="o">)){</span>
                    <span class="n">hs</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">keys</span> <span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">hs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">ks</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span><span class="n">hs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">keys</span><span class="o">)));</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
<span class="c1">// 전깃줄의 수에서 빼준다.</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">len</span> <span class="o">-</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">hs</span><span class="o">.</span><span class="na">values</span><span class="o">()));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<h4 id="체감-난이도--중">체감 난이도 : 중<br /></h4>
:ET