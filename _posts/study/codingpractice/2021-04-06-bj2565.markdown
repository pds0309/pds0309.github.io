---
layout: post
title: 백준-2565-전깃줄 (java)
date: 2021-04-06 11:11:10 +0900
category: 111CP
tag: study
mytag: [백준 , dp]
---

## 백준-2565-전깃줄

---
### [문제설명링크   ](https://www.acmicpc.net/problem/2565)
<br>  
  
* [풀이](#나의-풀이)
* [코드](#자바-풀이-코드)  

<br>  

### 문제요약 

* 두 전봇대 사이에 전깃줄이 있는데 모든 전깃줄이 교차하지 않게 전깃줄을 제거하는 최소 개수를 구하라.
* 한 위치에 두 개 이상의 전깃줄이 연결될 수는 없다.
<br>  


<br>
### 입력<br>
* 첫째 줄에 두 전본대 사이의 전깃줄 개수가 주어짐 <= 100
* 전봇대 A,B에 연결되는 전깃줄 번호가 주어짐 <= 500



### 출력  <br>   

* 첫째 줄에 남아있는 모든 전깃줄이 서로 교차하지 않게 하기 위해 없애야 하는 전깃줄의 최소 개수를 출력한다.



### 입력예시<br>  

8<br>
1 8<br>
3 9<br>
2 2<br>
4 1<br>
6 4<br>
10 10<br>
9 7<br>
7 6<br>


### 출력예시<br>    

3<br>

 

<br>

### 풀이<br> 
* 전깃줄 개수가 N이라면 
* A[N] : 왼쪽 전봇대에서의 전깃줄 번호를 오름차순으로 할 때 해당 인덱스의 오른쪽 전깃줄 번호 
* D[N] : 1~N번째 전깃줄 까지에서 교차하지 않는 전깃줄 최대개수
* D[N] 은 A[1]~A[N-1] < A[N] 인 부분에 대해서(전깃줄이 겹치지 않는 경우)  D[1]~D[N-1] 까지의 최대값 + 1이 된다.
<br>  

* D[N] 에서 가장 큰 값은 주어진 전깃줄들 중 겹치지 않는 가장 많은 부분에 대한 개수를 나타낸다.
	* 따라서 전체 전깃줄 개수에서 이 수를 빼면 정답이 된다.



<br>  
 	
 
### 자바 풀이 코드  

<br>

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class Main {

    public static void main(String[] args) throws IOException {
        BufferedReader b = new BufferedReader(new InputStreamReader(System.in));
        int len = Integer.parseInt(b.readLine());

        StringTokenizer st;
//주어진 전깃줄들을 왼쪽전봇대의 값을 key로하여 오름차순 정렬
        SortedMap<Integer,Integer> sm = new TreeMap<>();
        for(int i = 0 ; i < len ; i ++){
            st = new StringTokenizer(b.readLine());
            sm.put(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken()));
        }
// key는 왼쪽전봇대의 값 , value 는 해당 전깃줄까지 선택할 때 겹치지 않는 전깃줄의 수 최대값
        HashMap<Integer,Integer> hs = new HashMap<>();
// int keys 는 현재 전깃줄
        for(int keys: sm.keySet()){
            hs.put(keys , 1);
// int ks 는 이전의 전깃줄들
            for(int ks : sm.keySet()){
                if(ks >= keys){
                    break;
                }
// 현재 전깃줄보다 이전 전깃줄의 오른쪽 값이 작다면 겹치지 않는다는 뜻임
                if(sm.get(ks) < sm.get(keys)){
                    hs.put(keys , Math.max(hs.get(ks) + 1,hs.get(keys)));
                }
            }
        }
// 전깃줄의 수에서 빼준다.
        System.out.println(len - Collections.max(hs.values()));
    }
}

```


#### 체감 난이도 : 중<br>
