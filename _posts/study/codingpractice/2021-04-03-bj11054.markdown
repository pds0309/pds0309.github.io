---
layout: post
title: 백준-11054-가장긴바이토닉수열 (java)
date: 2021-04-03 12:11:10 +0900
category: 111CP
tag: study
mytag: [백준 , dp]
---

## 백준-11054-가장긴 바이토닉 수열

---
### [문제설명링크   ](https://www.acmicpc.net/problem/11054)
<br>  
  
* [풀이](#나의-풀이)
* [코드](#자바-풀이-코드)  

<br>  

### 문제요약 

* 수열 S가 있을 때  수열의 특정 값에 대해 <br>
왼쪽 부분과 오른쪽 부분이 각각 특정 값에 대해 내림차순일 때 바이토닉 수열이라고 한다. 
* EX) {10,20,**30,25,20} -  30을 기준으로 왼쪽과 오른쪽 값이 내림차순 정렬이 되어있다 - 바이토닉 수열
* 수열 A가 주어질 때 그 수열의 부분 수열 중 가장 긴 바이토닉 수열의 길이를 구해라.

<br>  


<br>
### 입력<br>
* 첫째 줄에 수열 A의 크기 N이 주어지고, 둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ N ≤ 1,000, 1 ≤ Ai ≤ 1,000)



### 출력  <br>   

* 첫째 줄에 수열 A의 부분 수열 중에서 가장 긴 바이토닉 수열의 길이를 출력한다.



### 입력예시<br>  

10<br>
1 5 2 1 4 3 4 5 2 1<br

### 출력예시<br>    

7<br>

 

<br>

### 풀이<br>  

1. 배열의 모든 인덱스를 각각 기준으로 정하고 오른쪽은 무시하고 왼쪽으로만 내림차순 할 때 최대의 길이를 구한다.<br>
2. 똑같이 기준을 정하고 왼쪽은 무시하고 오른쪽으로만 내림차순 할 때 최대의 길이를 구한다.
3. 과정 1과 과정 2를 더한다.  

* A[N] = {1,5,2,1,4,3,4,5,2,1} , F[N] : A[N]을 기준으로 했을 때 왼쪽으로 내림차순 배열이 될 때의 길이의 최대값 일 때
	* F[1] = {1} : 1
	* F[2] = {1,5} : 2
	* F[3] = {1,2} : 2
		* 기준인 A[3] : 2 < 5 로 내림차순이 될 수 없기 때문에 건너 뛴다.
	* F[4] = {1} : 1
		* 기준인 1과 왼쪽 모든 값을 비교했을 때 1보다 작지 않다.
	* F[5] = {1,2,4} : 3
		* A[1] < A[5] 로 A[5]가 기준일 때 답이 될 수 있다. : {1,4} : 2
			* 여기서 A[1] 이 기준일 때 왼쪽 내림차순의 최대 값은 F[1] 였다.
		* A[2] > A[5] 로 답이 될 수 없다.
		* A[3] < A[5] 로 A[5] : 4 가 기준일 때 답이 될 수 있다.
			* 여기서 A[3] 이 기준일 때 왼쪽 내림차순의 최대 값은 앞의 F[3] 에서 구해져있다.
			* 따라서 F[5] : {1,2,4} = 3이 된다.
				* {1,2} 는 A[3] 을 기준으로 했을 때 부분수열의 최대길이인 F[3] 에서 비롯된 것이다.
		* A[4] < A[5] 로 A[5]가 기준일 때 답이 될 수 있다. {1,4} : 2
			* 여기서 A[4] 가 기준일 때 왼쪽 내림차순의 최대 값은 F[4] 였다.
		* 구했던 값들 중 최대값이 기준값에 대한 내림차순 배열의 최대길이이다.
* 식
	* F[N] = MAX( 1 + (F[1] ~ F[N-1]))  ,  단 A[1] ~ A[N-1] < A[N] 일 때
	* 여기서 1은 자기 자신이다.
	* 여기서 오른쪽방향으로만의 내림차순인 과정2를 더하면 기준 값에 대해 왼쪽과 오른쪽이 모두 내림차순인 부분수열의 최대 길이 + 1이 된다.
		* 자기 자신을 식1과 식2에서 모두 더했기 때문에 - 1 을 해준다.

```java
int A[] = {1, 5, 2, 1, 4, 3, 4, 5, 2 ,1}
기준 값과 기준값의 왼쪽값들을 통해 얻을 수 있는 부분수열의 최대길이 : 1 2 2 1 3 3 4 5 2 1 
기준 값과 기준값의 오른값들을 통해 얻을 수 있는 부분수열의 최대길이 : 1 5 2 1 4 3 3 3 2 1
```




<br>  
 	
 
### 자바 풀이 코드  

<br>
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader b = new BufferedReader(new InputStreamReader(System.in));
        int len = Integer.parseInt(b.readLine());
        int arr[] = new int[len+1];
        StringTokenizer st = new StringTokenizer(b.readLine(), " ");
        for(int i = 1 ; i < len+1; i ++){
            arr[i] = Integer.parseInt(st.nextToken());
        }
        int front[] = new int[len+1];
        int rear[] = new int[len+1];


        for(int i = 1 ; i < len+1 ; i ++){
            front[i] = 1;
            for(int j = 1 ; j < i ; j ++){
                if(arr[i] > arr[j]){
                    front[i] = Math.max(front[i] , front[j]+1);
                }
            }
        }
        for(int i = len ; i >= 1; i --){
            rear[i] = 1;
            for(int j = len ; j > i ; j --){
                if(arr[i] > arr[j]){
                    rear[i] = Math.max(rear[i] , rear[j]+1);
                }
            }
            front[i] += rear[i] -1;
        }
        System.out.println(Arrays.stream(front).max().getAsInt());
    }
}
```


#### 체감 난이도 : 상<br>
* 접근 방법을 생각하지 못해서 다른사람의 해설을 보고 깨달음을 얻었다.  