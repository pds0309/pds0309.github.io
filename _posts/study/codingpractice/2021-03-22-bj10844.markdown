---
layout: post
title: 백준-10844-쉬운계단수
date: 2021-03-22 11:15:15 +0900
category: 111CP
tag: study
mytag: [백준 , dp]
---

## 백준-10844-쉬운 계단 수 

---
### [문제설명링크   ](https://www.acmicpc.net/problem/10844)
<br>  

### 문제요약
* N 이 주어질 때 N 자리 수의 계단수가 총 몇개 있는지 구하라.
* 계단수 : 인접한 자리의 숫자 차이가 모두 1인 수
<br>  



<br>
### 제한사항
* (1 <= N <= 100)
* 맨 앞에 0 은 안된다.   
 
> ex)  0123 :  X &nbsp;&nbsp;   1210 : O

<br>
### 입력

2

  

### 출력

17

<br>

### 나의 풀이<br>  

* N이 1일 때 result : 9 - 1,2,3,4,5,6,7,8,9
* N이 2일 때 result : 17 - 10 12 ... <br>
  
#### 현재구해야 할 자릿수 이전의 자릿수에서 맨 뒤의 숫자를 기준으로 할 때 현재 뒤에 가져다 붙이면 무슨 숫자가 올 수 있을 지 생각했다.<br>  


* N = 1 일 때 값이 있고 N = 2 를 구해야 할 때<br>  

|N|뒤에올수있는 수|
|----|-----------|
|1|&nbsp; -> 0 2|
|2|&nbsp; -> 1 3|
|3|&nbsp; -> 2 4|
|4|&nbsp; -> 3 5|
|5|&nbsp; -> 4 6|
|6|&nbsp; -> 5 7|
|7|&nbsp; -> 6 8|
|8|&nbsp; -> 7 9|
|9|&nbsp; -> 8|

<br>  
* 맨 뒤의 숫자가 1<=n<=8 일 경우 n-1 또는 n+1 이라는 두개의 숫자가 다음 숫자로 올 수 있다.
* 맨 뒤의 숫자가 0일 경우 다음 숫자는 1밖에 오지 못하고 9일 경우 8밖에 오지못한다.
<br>  

#### 이런 원리를 이용해 A[자릿수][10] 의 배열을 선언한다. - 자릿수에 따른 (0~9)마지막 수의 갯수이다.<br>  

> ex) A[2][5] :  2자리의 숫자들 중 마지막 값이 5일 때의 갯수이다.  <br>
> 이 때 세자리 계단 수를 만든다면 4 또는 6을 덧붙일 수 있다. 따라서 A[3][4] += A[2][5]  , A[3][6] += A[2][5] 라는 연산을 한다.
  
 




### 자바 풀이 코드  

<br>
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;
import java.util.stream.Collectors;

public class Main {

    public static void main(String[] args) throws IOException {
//입력
        BufferedReader b = new BufferedReader(new InputStreamReader(System.in));
        int A = Integer.parseInt(b.readLine());

//배열 선언 : arr[자리수][0~9]
        long arr[][] = new long[A+1][10];
//한 자리 수 일 때 0의 개수는 0이다.
        arr[1][0] = 0;
// 한자리 수 일 때 값 할당
        for(int i = 1 ; i < arr[0].length; i ++){
            arr[1][i] = 1;
        }
//입력 받은 A에 대한 값을 구하는 과정이다.
        for(int i = 2; i <= A ; i ++){
            for(int j = 0 ; j < arr[0].length; j ++){
                arr[i-1][j] %= 1000000000l;
// j  = 1~8 의 숫자라면 다음 숫자는 j-1 또는 j+1 이 올 수 있다.
                if(j>=1 && j <= 8){
// 이전 자리수에서의 (마지막 자리값): J 에 대한 개수를 현재 구해야 할 자리수의  J-1 J+1 의 개수에 할당해준다.
                    arr[i][j-1] += arr[i-1][j];
                    arr[i][j+1] += arr[i-1][j];
                }
// j = 0 일 때 
                else if (j == 0){
                    arr[i][j+1] += arr[i-1][j];
                }
// j = 9 일 때
                else{
                    arr[i][j-1] += arr[i-1][j];
                }

            }

        }
        long answer = 0;
//구해야 되는 자리수에 대한 가능한 모든 계단수의 수를 구한다.
        for(int i = 0 ; i < arr[0].length; i ++){
            answer += (arr[A][i]);

        }
        System.out.println(answer % 1000000000l);
        
    }
}


```


#### 체감 난이도 : 중
* 제목은 쉬운 계단 수인데 쉽지는 않은 것 같다.
* 처음에 집합으로 이전 자릿수를 기준으로 경우를 다 구해서 중복되는 값은 빠지고 개수를 세는 방식으로 풀었는데 답은 맞지만 n 이 30만 되도 오래걸렸다.
* 코드를 만드는데는 별로 안걸렸지만 구체적인 방법을 생각하는 것이 오래걸린 것 같다.  

![](/assets/img/10844.PNG)
