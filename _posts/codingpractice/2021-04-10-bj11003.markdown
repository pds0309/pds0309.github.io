---
layout: post
title: 백준-11003-최솟값 찾기 (java)
date: 2021-04-10 17:05:10 +0900
category2: codingpractice
category: Study Note
tag: [백준 , 자료구조]
---

## 백준-11003-최솟값 찾기

---
### [문제설명링크   ](https://www.acmicpc.net/problem/11003)
<br>  
  
* [풀이](#나의-풀이)
* [코드](#자바-풀이-코드)  

<br>  

### 문제요약 

* N개의 수 A1, A2, ..., AN과 L이 주어진다.

* Di = Ai-L+1 ~ Ai 중의 최솟값이라고 할 때, D에 저장된 수를 출력하는 프로그램을 작성하시오. 이때, i ≤ 0 인 Ai는 무시하고 D를 구해야 한다.  

<br>  


<br>
### 입력<br>
* 첫째 줄에 N과 L이 주어진다. (1 ≤ L ≤ N ≤ 5,000,000)

* 둘째 줄에는 N개의 수 Ai가 주어진다. (-109 ≤ Ai ≤ 109)

### 출력  <br>   

* 첫째 줄에 Di를 공백으로 구분하여 순서대로 출력한다.



### 입력예시<br>  

12 3<br>
1 5 2 3 6 2 3 7 3 5 2 6<br>

### 출력예시<br>    

1 1 1 2 2 2 2 2 3 3 2 2<br> 

 

<br>

### 풀이<br>

* 문제를 보고 덱이나 우선순위 큐를 활용하면 될 것 같다고 생각하였다.

1. 덱을 활용해서 범위에 따라 뒷 값을 넣어주고 앞 값을 빼면서 최대값을 찾아 출력하면 된다고 생각하고 풀었다.
	* 논리 자체는 맞았으나 시간초과 문제가 있었다.
2. 질문검색 게시판을 활용해 힌트나 질문 내용들을 확인하고 참고하였다.
	* [참고한 게시판](https://www.acmicpc.net/board/view/36231)
	* Deque -> ArrayDeque 활용
	* StringBuilder -> BufferedWriter 활용
	* 배열의 값 자체를 덱에 활용하지 말고 배열의 인덱스를 활용할 것
	* 덱의 push, poll 등 대신 offer , get 활용
	



### 자바 풀이 코드<br>  

```java
import java.io.*;
import java.util.ArrayDeque;
import java.util.StringTokenizer;

public class Main {
    public static void main(String args[]) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int l = Integer.parseInt(st.nextToken());
        int[] arr = new int[n];
        st = new StringTokenizer(br.readLine());

        ArrayDeque<Integer> deque = new ArrayDeque<>();

        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < n; i++) {
            //현재 인덱스에 대한 값 배열에 할당
            arr[i] = Integer.parseInt(st.nextToken());

            // 덱의 맨앞부분(최솟값)에 할당된 인덱스가 범위를 더 이상 만족하지 못할 때 제거해준다.
            if(!deque.isEmpty() && deque.getFirst() <= i - l) {
                deque.removeFirst();
            }
            // 새로 덱에 넣을 인덱스에 대한 값보다 큰 값에 대한 인덱스는 무조건 필요없기때문에 해당 값에 대한 인덱스들을 모두 덱에서 제거한다.
            while(!deque.isEmpty() && arr[deque.getLast()] > arr[i]) {
                deque.removeLast();
            }
            //덱에 현재 인덱스 저장
            deque.offer(i);
            // 최솟값 출력 , 덱의 앞부분에는 항상 정해진 범위에서의 최솟값의 인덱스가 할당되어있다.
            sb.append(arr[deque.getFirst()]).append(" ");
        }
        bw.write(sb.toString());
        bw.flush();
        bw.close();
    }
}

```


#### 체감 난이도 : 상<br>
* 논리자체는 어렵지 않았고 무식한 방법으로 잘 풀었지만 시간문제를 고려하지 못했다. 
* 참고한 풀이내용이 어렵게 느껴졌다. 나의 무식한 풀이방법과는 다르게 참고한 풀이에서는 최대값에 대한 비교조차 필요하지 않았다.