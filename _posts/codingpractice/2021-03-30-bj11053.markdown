---
layout: post
title: 백준-11053-가장 긴 증가하는 부분 수열 (java)
date: 2021-03-30 10:58:00 +0900
category2: codingpractice
category: Study Note
tag: [백준 , dp]
---

## 백준-11053-가장 긴 증가하는 부분 수열

---
### [문제설명링크   ](https://www.acmicpc.net/problem/11053)
<br>  
  
* [풀이](#나의-풀이)
* [코드](#자바-풀이-코드)  

<br>  

### 문제요약 

* 수열이 주어졌을 때 증가하는 수열 중 가장 길 때의 길이를 출력하라.

   
<br>  

<br>

<br>
### 입력<br>
* 첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.

* 둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)



### 출력  <br>   

* 첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.


### 입력예시<br>  

6<br>
10 20 10 30 20 50<br>

### 출력예시<br>  
  
4<br>  

 



<br>

### 나의 풀이<br>  
  
* A[6] = {10,20,10,30,20,50}   
* D[N] : A[1]~A[N] 까지의 수열 중에서 가장 긴 부분수열의 길이  

* D[1]
	*  1
* D[2] : A[2] = 20 > A[1] 로 부분수열의 길이가 2다. 부분수열 : [10,20]
	*  2
* D[3] : A[3] = 10 < A[2] 로 부분수열의 길이가 1이다.
	*  1
* D[4] : A[4] = 30 > A[3] 이면서 현재까지 가장 긴 부분수열이었던 [10,20] 의 최대값보다  크다.<br>
	따라서 길이는 [10 20 30] 으로 3이된다.
	*  3
* D[5] : A[5] =  20 < A[4]  이면서 A[5] > A[3] 이다. 
	*  2 
* D[6] : 50 > A[1~5]보다 크다. A[1~5]에서 가장 긴 부분수열의 길이 + 1 이 될 것이다.
	* 4

* 식
	* **D[N]** = MAX( D[1~(N-1)] ) + 1  , 단 A[N] > A[1~(N-1)] 일때


<br>  
 	
 
### 자바 풀이 코드  

<br>
```java
public class Main {
    public static void main(String[] args) throws IOException {

        BufferedReader b = new BufferedReader(new InputStreamReader(System.in));
        int len = Integer.parseInt(b.readLine());
        StringTokenizer st = new StringTokenizer(b.readLine());
 
        int arr[] = new int[len];
        int d[] = new int[len];

        for(int i = 0 ; i < len ; i ++){
            arr[i] = Integer.parseInt(st.nextToken());
        }

        for(int i = 0 ; i < len ; i ++) {

            int max = 0;
            d[i] = 1;

            for (int j = 0; j < i; j++) {
                if (arr[i] > arr[j]) {
                    max = Math.max(max , d[j]);
                }
            }
            d[i] = max + 1;
        }
        System.out.println(Arrays.stream(d).max().getAsInt());
    }
}

```


#### 체감 난이도 : 하<br>  
