---
layout: post
title: 백준-11066-파일합치기 (java)
date: 2021-03-28 13:19:20 +0900
category2: codingpractice
category: Study Note
tag: [백준 , dp]
---

## 백준-11066-파일합치기  

---
### [문제설명링크   ](https://www.acmicpc.net/problem/11066)
<br>  
  
* [풀이](#나의-풀이)
* [코드](#자바-풀이-코드)  

<br>  

### 문제요약 

* 소설 하나를 위한 여러 파일과 각 파일의 결합비용이 주어질 때 <br>
파일 두개를 합치면 하나의 임시파일이 된다.
* 파일을 모두 합쳐 하나의 최종파일을 만들 때 최소비용을 구하는 것.
* 인접한 파일끼리만 합칠 수 있다.<br>  
  
> ex) 20:A 30:B 10:C  -> min ( (A+B) + C , A + (B+C) )  = min( 50 + 60 , 40 + 60) = 100  
   
<br>  

<br>

<br>
### 입력<br>
* 프로그램은 표준 입력에서 입력 데이터를 받는다. <br>
프로그램의 입력은 T개의 테스트 데이터로 이루어져 있는데, T는 입력의 맨 첫 줄에 주어진다.<br>
각 테스트 데이터는 두 개의 행으로 주어지는데, 첫 행에는 소설을 구성하는 장의 수를 나타내는 양의 정수 K (3 ≤ K ≤ 500)가 주어진다. <br>
두 번째 행에는 1장부터 K장까지 수록한 파일의 크기를 나타내는 양의 정수 K개가 주어진다. <br>
파일의 크기는 10,000을 초과하지 않는다.
<br>  

### 출력  <br>  
* 소설 하나에서 최종 파일을 만드는 것에 대한 최소비용  


### 입력예시<br>  

2<br>
4<br>
40 30 30 50<br>
15<br>
1 21 3 4 5 35 5 4 3 5 98 21 14 17 32<br>

### 출력예시<br>  
  
300<br>
864<br>  



<br>

### 나의 풀이<br>  
  
* 1 ~ N개의 파일을 합칠 때 최솟값을 차근차근 생각해보기로 했다.  ( 예시로 5개라고 가정 )<br>  
* **A[5]** = {20, 30 , 10 , 40 , 60}  
* **DP[N1][N2]** : N1에서 N2 까지 파일을 합쳤을 때 비용의 최솟값  
> ex) DP[1][3] : 1~3번째 파일 까지 합쳤을 때 비용의 최솟값  
> ex) DP[2][3] : 2,3번째 파일을 합칠 때 비용의 최솟값 : 40
  
<br>  

* N = 2
	* **DP[1][2]** = 50 = 20 + 30  
	* **DP[2][3]** = 40 = 30 + 10
	* **DP[3][4]** = 50 = 10 + 40
	* **DP[4][5]** = 100 = 40 + 60  
 
* N = 3  
	* **DP[1][3]** = MIN ( DP[1][2] + A[3] , DP[2][3] + A[1] ) = MIN ( 50 + **60**  , 40 + **60** ) = 100 &nbsp;[(1)](#)
	* **DP[2][4]** = MIN ( DP[2][3] + A[4] , DP[3][4] + A[2] ) = MIN ( 40 + **80**  , 50 + **80** ) = 120
	* **DP[3][5]** = MIN ( DP[3][4] + A[5] , DP[4][5] + A[3] ) = MIN ( 50 + **110** , 100 + **110** ) = 160  <br>  
* 두개를 결합하고 하나의 파일이 남았을 때 사실 남은 파일을 더하는 것이아니라 DP[i][j] 라면 A[i]~A[j] 까지의 모든 값을 더하는 것이다.  
* 즉 [(1)](#111) 에서 <br>  
DP[1][3] = MIN ( DP[1][2] + **A[3]** , DP[2][3] + **A[1]** ) 가 아니라<br>  
DP[1][3] = MIN ( DP[1][2] + [DP[3][3]](#) , DP[2][3] + [DP[1][1]](#) )  + A[1] + A[2] + A[3]  인 것이다.<br>  
자기자신끼리는 합칠 수 없으니 DP[n][n] = 0 이다. <br>  


<br>  

* N = 4
	* **DP[1][4]** = MIN (DP[1][1] + DP[2][4] , DP[1][2] + DP[3][4] , DP[1][3] + DP[4][4] ) + SUM ( A[1:4] )
	* **DP[2][5]** = MIN (DP[2][2] + DP[3][5] , DP[2][3] + DP[4][5] , DP[2][4] + DP[5][5] ) + SUM ( A[2:5] )  
  
* N = 5 : 구해야할 답
	* DP[1][5] = MIN (  DP[1][[1](#)] + DP[[2](#)][5]  , DP[1][[2](#)] + DP[[3](#)][5] , DP[1][[3](#)] + DP[[4](#)][5] + DP[1][[4](#)] + DP[[5](#)][5] ) + SUM(A)  
	* 다 아는 얼굴들이 나온다.  
<br>  
  
* 식 :
	* i : 시작위치 &nbsp;&nbsp;&nbsp; j : 마지막위치 &nbsp;&nbsp;&nbsp; k : (i <= k < j )  
	* 위의 N = 5 의 DP[1][5] 에서 파란색 부분이 k 에 대한 부분이다.
	* DP[i][j] = MIN ( DP[i][k] + DP[k+1][j]) + SUM(A[i ~ j]) 
  
<br>  
 
### 자바 풀이 코드  

<br>
```java

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Main{

    public static void main(String[] args) throws IOException {
        BufferedReader b = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;
        StringBuilder sb = new StringBuilder();
// 소설 수
        int n = Integer.parseInt(b.readLine());

// 각 소설에 대한 루프
        for(int i = 0 ; i < n ; i ++){
	
// 해당 소설의 파일 수
            int len = Integer.parseInt(b.readLine());
// 해당 소설의 파일에 대한 결합 비용
            int arr[] = new int[len+1];
// sum[i][j] : i번째 파일 ~ j번째 파일들을 모두 합칠 때 최소 비용
            int sum[][] = new int[len+1][len+1];
            st = new StringTokenizer(b.readLine());

            for(int j = 1 ; j < len + 1 ; j ++){
                arr[j] = Integer.parseInt(st.nextToken());
                sum[j-1][j] = arr[j-1] + arr[j];
            }
// ex ) len = 6 이고 1-3 -> 1번째 ~ 3번째 결합 최소 비용 일 때 
// 1-3 2-4 3-5 4-6 , 1-4 2-5 3-6 , 1-5 2-6 , 1-6 의 순서대로 돌면서
// sum[j][j+k] 값을 이전에 저장된 값들을 이용해 최솟값을 찾아 할당함.
            int k = 2;
            while(k <= len-1) {
                for (int j = 1; j < len + 1 - k; j++) {
                    int min = Integer.MAX_VALUE;
// temp =  A[j] ~ A[j+k] 까지의 합
                    int temp = Arrays.stream(Arrays.copyOfRange(arr , j , j + k+1)).sum();
	// 식
                    for(int l = j ; l < (j+k) ; l ++){
                        min = Math.min(min , sum[j][l] + sum[l+1][j+k] + temp);
                    }
                    sum[j][j+k] = min;
                }
                k++;
            }
            sb.append(sum[1][len]).append("\n");
        }
        System.out.println(sb);
    }
}


```


#### 체감 난이도 : 상<br>  
* 식을 생각하는데 너무 오래걸렸고 어려웠다.
* Java 로 제출한 사람들 중 메모리 사용량이 뒤에서 1등이었다. 
* 잊어버릴 때 쯤 다시 한번 풀어보고 더 효율적인 다른 사람의 코드를 보고 공부해야 할 것이다.